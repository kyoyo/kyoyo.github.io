---
layout: post
title: Django
category: 技术
tags: Django
keywords: 
description: 
---


## 开发环境准备

```
#安装django
pip3 install -v django==1.10.7

#创建virtualenv
virtualenv django-env

#激活virtualenv
.\django-env\Scripts\activate.bat

#--------------------------------
#virtualenvwrapper神器

#virtualenv 的一个最大的缺点就是，每次开启虚拟环境之前要去虚拟环境所在目录下的 bin 
#目录下 source 一下 activate，这就需要我们记住每个虚拟环境所在的目录。一种可行的
#解决方案是，将所有的虚拟环境目录全都集中起来，
#比如放到 ~/virtualenvs/，并对不同的虚拟环境使用不同的目录来管理。
#virtualenvwrapper 正是这样做的。并且，它还省去了每次
#开启虚拟环境时候的 source 操作，使得虚拟环境更加好用。

#安装
export VIRTUALENVWRAPPER_PYTHON=/usr/local/bin/python3
pip install virtualenvwrapper

#环境设定
export WORKON_HOME='~/.virtualenvs'
source /usr/local/bin/virtualenvwrapper.sh

#Create a new virtualenv in the WORKON_HOME directory
mkvirtualenv spider

#List all of the environments
lsvirtualenv

#show the content of the site-packages directory of the currently-active virtualenv.
lssitepackages

#List or change working virtual environments
workon spider

#退出虚拟环境
deactivate

#删除虚拟环境
rmvirtualenv spider

#--------------------------------
#创建新工程
django-admin.py startproject MyBlog

#创建app
python manage.py startapp article

#start web server
manage.py runserver

#同步生成DB 仅在第一次用
python manage.py migrate

#之后编辑model后，都要执行这两个
python manage.py makemigrations
python manage.py migrate

#创建超级用户
python manage.py createsuperuser

#python交互环境变量设置
import os
import django
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "MyBlog.settings")
django.setup()

#settings

## database sqlite3 
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'MyBlog.db'),
    }
}

## Static files (CSS, JavaScript, Images)
  STATICFILES = os.path.join(BASE_DIR, 'static')

```

## Setting

- [LANGUAGE_CODE reference](http://www.i18nguy.com/unicode/language-identifiers.html) 
- [TIME_ZONE reference](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)

```
LANGUAGE_CODE = 'ja'
TIME_ZONE = 'Asia/Tokyo'

LANGUAGE_CODE = 'zh-hans'
TIME_ZONE = 'Asia/Shanghai'
```

## The view layer

### libs
```
#views lib
from django.shortcuts import render
from django.http import HttpResponse
from django.conf import settings

from django.views.generic import ListView,DetailView
django.views.generic
__all__ = [
    'View', 'TemplateView', 'RedirectView', 'ArchiveIndexView',
    'YearArchiveView', 'MonthArchiveView', 'WeekArchiveView', 'DayArchiveView',
    'TodayArchiveView', 'DateDetailView', 'DetailView', 'FormView',
    'CreateView', 'UpdateView', 'DeleteView', 'ListView', 'GenericViewError',
]

#常用成员变量和方法
-ListView
template_name
context_object_name
get_queryset

--分页
page_type
paginate_by
page_kwarg

-DetailView
template_name
model
pk_url_kwarg
context_object_name
get_object
get_context_data

-FormView
form_class
template_name
form_valid
form_invalid
get_context_data (第一次显示form和form_invalid时调用)


-RedirectView
get


```

### urls
```
#eg.
url(r'^$', views.IndexView.as_view(), name='index')
url(r'^page/(?P<page>\d+)$', views.IndexView.as_view(), name='index_page'),
url(r'^article/(?P<year>\d+)/(?P<month>\d+)/(?P<day>\d+)/(?P<article_id>\d+).html$',
        views.ArticleDetailView.as_view(),
        name='detail'),
url(r'^category/(?P<category_name>\S+).html$',views.CategoryDetailView.as_view(),name='category_detail'

#regrex
(?P<year>\d+) group匹配

* 匹配前一个字符0次或无限次
+ 匹配前一个字符1次或无限次
? 匹配前一个字符0次或1次
\d 数字[0-9]
\s 空白字符
\S 非空白字符
\w 单词字符[A-Za-z0-9_]

```
### paginator
```
url(r'^page/(?P<page>\d+)$', views.IndexView.as_view(), name='index_page'),
context = {
                'paginator': paginator,
                'page_obj': page,
                'is_paginated': is_paginated,
                'object_list': queryset
}
```

### tags
```

#tag
from django import template
from django.template.defaultfilters import stringfilter
from django.conf import settings

register = template.Library()

@register.simple_tag
@register.inclusion_tag('blog/tags/breadcrumb.html')

@register.filter(is_safe=True)
@stringfilter

#将函数处理的结果赋值给一个变量
@register.assignment_tag

```

## The model layer
```
#lib
from django.db import models
from django.core.urlresolvers import reverse

#auth
AUTH_USER_MODEL='auth.User'

```


## The template layer

### 配置
```
#TEMPLATES
TEMPLATES 'DIRS': [os.path.join(BASE_DIR, 'templates')]
```

### 代码实例
```
#ModelForm实现例子
class CommentForm(ModelForm):
    url = forms.URLField(label='网址',required=False)
    email = forms.EmailField(label='电子邮箱', required=False)
    name = forms.CharField(label='姓名')
    parent_comment_id = forms.IntegerField(widget=forms.HiddenInput, required= False)


    class Meta:
        model = Comment
        fields = ['body']class CommentForm(ModelForm):
    url = forms.URLField(label='网址',required=False)
    email = forms.EmailField(label='电子邮箱', required=False)
    name = forms.CharField(label='姓名')
    parent_comment_id = forms.IntegerField(widget=forms.HiddenInput, required= False)


    class Meta:
        model = Comment
        fields = ['body']
        
#AuthenticationForm,UserCreationForm实现例子
class LoginForm(AuthenticationForm):
    def __init__(self,*args,**kwargs):
        super(LoginForm,self).__init__(*args,**kwargs)
        self.fields['username'].widget = widgets.TextInput(attrs={'placeholder':'username','class':'form-control'})
        self.fields['password'].widget = widgets.PasswordInput(attrs={'placeholder':'password','class':'form-control'})


class RegisterForm(UserCreationForm):
    def __init__(self,*args,**kwargs):
        super(RegisterForm,self).__init__(*args,**kwargs)

        self.fields['username'].widget = widgets.TextInput(attrs={'placeholder':'username','class':'form-control'})
        self.fields['email'].widget = widgets.EmailInput(attrs={'placeholder':'email','class':'form-control'})
        self.fields['password1'].widget = widgets.PasswordInput(attrs={'placeholder':'password','class':'form-control'})
        self.fields['password2'].widget = widgets.PasswordInput(attrs={'placeholder':'repeat password','class':'form-control'})

    class Meta:
        model = get_user_model()
        fields = ('username','email')
```

### formset
```
from django import forms
class ArticleForm(forms.Form): 
    title = forms.CharField()
    pub_date = forms.DateField()
    
from django.forms import formset_factory
ArticleFormSet = formset_factory(ArticleForm,extra=2)
formset = ArticleFormSet()
for form in formset:
    print(form.as_table())

# 表单内的errors,规则验证
formset.errors
#调单外的逻辑验证
formset.non_form_errors
```

### forms知识点
```
ManyToManyField Django 创建一个中间表来表示ManyToManyField关系。默认情况下，中间表的名称由两个关系表名结合而成。

new_blog=form.save(commit=False) 
new_blog.author=current_user 

##保存时，有两种方式
1.先通过new_blog.save() 保存blog数据，再通过form.save_m2m() manytomany关系到中间表
new_blog.save() 
form.save_m2m() 
2.此方法保存blog数据和保存manytomany关系到中间表
form.save()
```

## The admin layer
```
from django.contrib import admin
admin.site.register(Article)
```

## Django API
```
#settings
import sys
import os
from django.conf import settings

BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

#apps
from django.apps import AppConfig

#urls
from django.conf.urls import url, include
from django.contrib import admin
from django.conf import settings
from django.conf.urls.static import static
from django.core.urlresolvers import reverse

#admin
from django.contrib import admin

#tags
from django import template
from django.template.defaultfilters import stringfilter
from django.utils.safestring import mark_safe

register = template.Library()

#用法:
@register.assignment_tag


@register.assignment_tag

@register.inclusion_tag('comments/tags/comment_item.html')

@register.simple_tag

@register.filter(is_safe=True)

@register.filter


#views
from django.http import HttpResponse
from django.http import HttpResponseRedirect

from django.shortcuts import render
from django.views.generic.list import ListView
from django.views.generic.detail import DetailView
from django.views.generic.edit import FormView
from django.contrib.sites.models import Site

from django.contrib.auth import get_user_model
from django.contrib import auth

auth.login(self.request, form.get_user())

#forms
from django import forms
from django.forms import ModelForm
from django.forms import widgets
from django.contrib.auth.forms import AuthenticationForm, UserCreationForm


#models
from django.db import models

```


## django部署
- [使用PythonAnyWhere和GitHub免费部署Django网站](https://segmentfault.com/a/1190000009240824)
- [如何在阿里云上部署 Django 应用程序](https://www.alibabacloud.com/zh/getting-started/projects/how-to-deploy-django-application-on-alibaba-cloud)

## ERRORS 
```
#error1
error:Add or change a related_name argument to the definition for 'BlogUser.groups' or 'User.groups'.
solution:AUTH_USER_MODEL='accounts.BlogUser'

#error2
error:django makemigrations no changes detected
solution:python manage.py makemigrations --empty yourappname 生成一个空的initial.py

#error3
error:Site matching query does not exist
solution:

from django.contrib.sites.models import Site
new_site = Site.objects.create(domain='foo.com', name='foo.com')
print new_site.id

```

## Django 开源项目
- [pinax](http://pinaxproject.com/) 这是我看到的最有价值的django开源项目。pinax可以看做是django的一个脚手架。她提供了快速开始一个新django项目的方法，同时对大 量第三方app的使用方法进行了演示。django的app质量参差不齐，如果你想挑选app，那你可以看看pinax里都集成了哪些app。pinax 里集成了的app通常都不至于太烂。此外pinax自身也带了一些有用的app，比如blog等。
如果你想以最快的速度了解pinax，可以去 http://cloud27.com/ 看看。这是一个用pinax搭建的SNS网站。
- [Satchmo](http://www.satchmoproject.com/) 网店系统。看她的介绍，似乎已经有不少人在用这东西了。
- [LFS(Lightning Fast Shop)] (http://www.getlfs.com/)网店系统，就Demo来看似乎是倾向于房屋交易平台。陆陆续续的也有部分商业网站开始使用该系统了，比如这个。

## 数据库升级
在项目开发过程中表结构的变动总是难免，django目前还不支持表结构的自动更新，不过相关的第三方app倒不少。这些app各有各的特色，具体如何选择就要看个人的喜好了。[SchemaEvolution](http://code.djangoproject.com/wiki/SchemaEvolution) 介绍django数据库升级的wiki页面，相关的app都可以在这个页面找到。

## Django apps

- django-registration 注册功能，支持帐户的邮件激活。
- django-tagging 为站点增加tagging功能
- django-voting 投票功能
- django-ajax-validation 使用ajax方式对表单进行校验，需要jquery的支持。这个组件只能校验，如果需要增加ajax提交表单的功能，还需要自己手动做些修改。
- django-announcements 发送站内公告，该公告只显示一次。可以设置公共的发送对象（所有人，指定用户，登陆用户）。
- django-avatar 为用户增加设置个人头像的功能。支持 http://www.gravatar.com/ 和用户上传头像。
- django-dbtemplates 将django的template保存在数据库，并通过cache来加速template的加载。这样可以很方便的通过admin来编辑template。我想这东西应当可以用来实现一些简单的CMS功能，不过似乎用处不是太大。
- django-microblogging 类似Twitter的微型博客
- django-notification 消息分发组件，用来实现类似好友最新动态的功能。
- django-pagination 一组翻页相关的utils，包括用于实现翻页的tag等。
- django-robots 通过django的admin来管理robots.txt。不过我觉得robots.txt这东西为什么还需要用admin来管理，还不如直接编辑来的方便。
- django-messages 实现站内消息的功能。目前该组件的功能的功能还比较弱，虽然作者在进行重构，但似乎进展缓慢。如果有需要我可能会自行对该组件进行一些增强。
- django-threadedcomments 评论组件，可以给任何的models增加评论功能。
- django-extensions 一些全局的 management extensions。其中包括create_app的增强，使用werkzeug做开发服务器等功能。
- django-uni-form 以div方式渲染forms
- django-timezones 时区设置组件，允许用户设置自己所在的时区。
- django-bookmarks 书签管理组件
- django-email-confirmation 在用户设置邮件地址后，给用户的邮箱发送一封确认邮件。用户点击邮件里的link来确认邮件地址的有效性。
- django-mailer 邮件发送的增强组件，会在邮件发送失败时记录失败日志。
- django-friends 朋友组件，支持邀请用户成为好友等。
- django-locations 似乎是一个基于地区的社交网络，需要yaohoo map的支持。
- django-oembed 方面媒体（视频等）内容嵌入，自动将媒体的连接转换成正确的html代码。
- django-swaps 易物平台，比如用PSP换NDS啥的。
- django-wikiapp wiki组件，支持多种wiki语法。不过目前该组件的功能还是比较简单，比如不支持附件。
- django-mptt 用于生成树形列表的app。如果你认为它会自动给你生成一个完整的树，那你就错了，她只是一组工具。我感觉这东西并不是太好用，是否有什么优点，暂时不太清楚。
- django-photologue 图片管理，上传图片，缩略图显示等。
- django-filebrowser django-admin的一个扩展，可以直接通过admin对服务器上的文件进行管理。我没用过这东西，不过看介绍，感觉非常棒。
- goflow Django上的一个工作流引擎，设计灵感来源于OpenFlow。没用过这东西，对工作流也不太了解，所以也不知道这东西好不好。不过这似乎是django上唯一的一个工作流app。



